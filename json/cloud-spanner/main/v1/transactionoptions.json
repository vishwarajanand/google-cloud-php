{"id":"spanner\/v1\/transactionoptions","type":"","title":"Google\\Cloud\\Spanner\\V1\\TransactionOptions","name":"TransactionOptions","description":"<p>Transactions:\nEach session can have at most one active transaction at a time (note that\nstandalone reads and queries use a transaction internally and do count\ntowards the one transaction limit). After the active transaction is\ncompleted, the session can immediately be re-used for the next transaction.<\/p>\n<p>It is not necessary to create a new session for each transaction.\nTransaction modes:\nCloud Spanner supports three transaction modes:<\/p>\n<ol>\n<li>Locking read-write. This type of transaction is the only way\nto write data into Cloud Spanner. These transactions rely on\npessimistic locking and, if necessary, two-phase commit.\nLocking read-write transactions may abort, requiring the\napplication to retry.<\/li>\n<li>Snapshot read-only. Snapshot read-only transactions provide guaranteed\nconsistency across several reads, but do not allow\nwrites. Snapshot read-only transactions can be configured to read at\ntimestamps in the past, or configured to perform a strong read\n(where Spanner will select a timestamp such that the read is\nguaranteed to see the effects of all transactions that have committed\nbefore the start of the read). Snapshot read-only transactions do not\nneed to be committed.\nQueries on change streams must be performed with the snapshot read-only\ntransaction mode, specifying a strong read. Please see\n[TransactionOptions.ReadOnly.strong][google.spanner.v1.TransactionOptions.ReadOnly.strong] for more details.<\/li>\n<li>Partitioned DML. This type of transaction is used to execute\na single Partitioned DML statement. Partitioned DML partitions\nthe key space and runs the DML statement over each partition\nin parallel using separate, internal transactions that commit\nindependently. Partitioned DML transactions do not need to be\ncommitted.\nFor transactions that only read, snapshot read-only transactions\nprovide simpler semantics and are almost always faster. In\nparticular, read-only transactions do not take locks, so they do\nnot conflict with read-write transactions. As a consequence of not\ntaking locks, they also do not abort, so retry loops are not needed.\nTransactions may only read-write data in a single database. They\nmay, however, read-write data in different tables within that\ndatabase.\nLocking read-write transactions:\nLocking transactions may be used to atomically read-modify-write\ndata anywhere in a database. This type of transaction is externally\nconsistent.\nClients should attempt to minimize the amount of time a transaction\nis active. Faster transactions commit with higher probability\nand cause less contention. Cloud Spanner attempts to keep read locks\nactive as long as the transaction continues to do reads, and the\ntransaction has not been terminated by\n[Commit][google.spanner.v1.Spanner.Commit] or\n[Rollback][google.spanner.v1.Spanner.Rollback]. Long periods of\ninactivity at the client may cause Cloud Spanner to release a\ntransaction's locks and abort it.\nConceptually, a read-write transaction consists of zero or more\nreads or SQL statements followed by\n[Commit][google.spanner.v1.Spanner.Commit]. At any time before\n[Commit][google.spanner.v1.Spanner.Commit], the client can send a\n[Rollback][google.spanner.v1.Spanner.Rollback] request to abort the\ntransaction.\nSemantics:\nCloud Spanner can commit the transaction if all read locks it acquired\nare still valid at commit time, and it is able to acquire write\nlocks for all writes. Cloud Spanner can abort the transaction for any\nreason. If a commit attempt returns <code>ABORTED<\/code>, Cloud Spanner guarantees\nthat the transaction has not modified any user data in Cloud Spanner.\nUnless the transaction commits, Cloud Spanner makes no guarantees about\nhow long the transaction's locks were held for. It is an error to\nuse Cloud Spanner locks for any sort of mutual exclusion other than\nbetween Cloud Spanner transactions themselves.\nRetrying aborted transactions:\nWhen a transaction aborts, the application can choose to retry the\nwhole transaction again. To maximize the chances of successfully\ncommitting the retry, the client should execute the retry in the\nsame session as the original attempt. The original session's lock\npriority increases with each consecutive abort, meaning that each\nattempt has a slightly better chance of success than the previous.\nUnder some circumstances (for example, many transactions attempting to\nmodify the same row(s)), a transaction can abort many times in a\nshort period before successfully committing. Thus, it is not a good\nidea to cap the number of retries a transaction can attempt;\ninstead, it is better to limit the total amount of time spent\nretrying.\nIdle transactions:\nA transaction is considered idle if it has no outstanding reads or\nSQL queries and has not started a read or SQL query within the last 10\nseconds. Idle transactions can be aborted by Cloud Spanner so that they\ndon't hold on to locks indefinitely. If an idle transaction is aborted, the\ncommit will fail with error <code>ABORTED<\/code>.\nIf this behavior is undesirable, periodically executing a simple\nSQL query in the transaction (for example, <code>SELECT 1<\/code>) prevents the\ntransaction from becoming idle.\nSnapshot read-only transactions:\nSnapshot read-only transactions provides a simpler method than\nlocking read-write transactions for doing several consistent\nreads. However, this type of transaction does not support writes.\nSnapshot transactions do not take locks. Instead, they work by\nchoosing a Cloud Spanner timestamp, then executing all reads at that\ntimestamp. Since they do not acquire locks, they do not block\nconcurrent read-write transactions.\nUnlike locking read-write transactions, snapshot read-only\ntransactions never abort. They can fail if the chosen read\ntimestamp is garbage collected; however, the default garbage\ncollection policy is generous enough that most applications do not\nneed to worry about this in practice.\nSnapshot read-only transactions do not need to call\n[Commit][google.spanner.v1.Spanner.Commit] or\n[Rollback][google.spanner.v1.Spanner.Rollback] (and in fact are not\npermitted to do so).\nTo execute a snapshot transaction, the client specifies a timestamp\nbound, which tells Cloud Spanner how to choose a read timestamp.\nThe types of timestamp bound are:\n<ul>\n<li>Strong (the default).<\/li>\n<li>Bounded staleness.<\/li>\n<li>Exact staleness.\nIf the Cloud Spanner database to be read is geographically distributed,\nstale read-only transactions can execute more quickly than strong\nor read-write transactions, because they are able to execute far\nfrom the leader replica.\nEach type of timestamp bound is discussed in detail below.\nStrong: Strong reads are guaranteed to see the effects of all transactions\nthat have committed before the start of the read. Furthermore, all\nrows yielded by a single read are consistent with each other -- if\nany part of the read observes a transaction, all parts of the read\nsee the transaction.\nStrong reads are not repeatable: two consecutive strong read-only\ntransactions might return inconsistent results if there are\nconcurrent writes. If consistency across reads is required, the\nreads should be executed within a transaction or at an exact read\ntimestamp.\nQueries on change streams (see below for more details) must also specify\nthe strong read timestamp bound.\nSee [TransactionOptions.ReadOnly.strong][google.spanner.v1.TransactionOptions.ReadOnly.strong].\nExact staleness:\nThese timestamp bounds execute reads at a user-specified\ntimestamp. Reads at a timestamp are guaranteed to see a consistent\nprefix of the global transaction history: they observe\nmodifications done by all transactions with a commit timestamp less than or\nequal to the read timestamp, and observe none of the modifications done by\ntransactions with a larger commit timestamp. They will block until\nall conflicting transactions that may be assigned commit timestamps\n&lt;= the read timestamp have finished.\nThe timestamp can either be expressed as an absolute Cloud Spanner commit\ntimestamp or a staleness relative to the current time.\nThese modes do not require a &quot;negotiation phase&quot; to pick a\ntimestamp. As a result, they execute slightly faster than the\nequivalent boundedly stale concurrency modes. On the other hand,\nboundedly stale reads usually return fresher results.\nSee [TransactionOptions.ReadOnly.read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.read_timestamp] and\n[TransactionOptions.ReadOnly.exact_staleness][google.spanner.v1.TransactionOptions.ReadOnly.exact_staleness].\nBounded staleness:\nBounded staleness modes allow Cloud Spanner to pick the read timestamp,\nsubject to a user-provided staleness bound. Cloud Spanner chooses the\nnewest timestamp within the staleness bound that allows execution\nof the reads at the closest available replica without blocking.\nAll rows yielded are consistent with each other -- if any part of\nthe read observes a transaction, all parts of the read see the\ntransaction. Boundedly stale reads are not repeatable: two stale\nreads, even if they use the same staleness bound, can execute at\ndifferent timestamps and thus return inconsistent results.\nBoundedly stale reads execute in two phases: the first phase\nnegotiates a timestamp among all replicas needed to serve the\nread. In the second phase, reads are executed at the negotiated\ntimestamp.\nAs a result of the two phase execution, bounded staleness reads are\nusually a little slower than comparable exact staleness\nreads. However, they are typically able to return fresher\nresults, and are more likely to execute at the closest replica.\nBecause the timestamp negotiation requires up-front knowledge of\nwhich rows will be read, it can only be used with single-use\nread-only transactions.\nSee [TransactionOptions.ReadOnly.max_staleness][google.spanner.v1.TransactionOptions.ReadOnly.max_staleness] and\n[TransactionOptions.ReadOnly.min_read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.min_read_timestamp].\nOld read timestamps and garbage collection:\nCloud Spanner continuously garbage collects deleted and overwritten data\nin the background to reclaim storage space. This process is known\nas &quot;version GC&quot;. By default, version GC reclaims versions after they\nare one hour old. Because of this, Cloud Spanner cannot perform reads\nat read timestamps more than one hour in the past. This\nrestriction also applies to in-progress reads and\/or SQL queries whose\ntimestamp become too old while executing. Reads and SQL queries with\ntoo-old read timestamps fail with the error <code>FAILED_PRECONDITION<\/code>.\nYou can configure and extend the <code>VERSION_RETENTION_PERIOD<\/code> of a\ndatabase up to a period as long as one week, which allows Cloud Spanner\nto perform reads up to one week in the past.\nQuerying change Streams:\nA Change Stream is a schema object that can be configured to watch data\nchanges on the entire database, a set of tables, or a set of columns\nin a database.\nWhen a change stream is created, Spanner automatically defines a\ncorresponding SQL Table-Valued Function (TVF) that can be used to query\nthe change records in the associated change stream using the\nExecuteStreamingSql API. The name of the TVF for a change stream is\ngenerated from the name of the change stream: READ_<change_stream_name>.\nAll queries on change stream TVFs must be executed using the\nExecuteStreamingSql API with a single-use read-only transaction with a\nstrong read-only timestamp_bound. The change stream TVF allows users to\nspecify the start_timestamp and end_timestamp for the time range of\ninterest. All change records within the retention period is accessible\nusing the strong read-only timestamp_bound. All other TransactionOptions\nare invalid for change stream queries.\nIn addition, if TransactionOptions.read_only.return_read_timestamp is set\nto true, a special value of 2^63 - 2 will be returned in the\n[Transaction][google.spanner.v1.Transaction] message that describes the\ntransaction, instead of a valid read timestamp. This special value should be\ndiscarded and not used for any subsequent queries.\nPlease see <a href=\"https:\/\/cloud.google.com\/spanner\/docs\/change-streams\">https:\/\/cloud.google.com\/spanner\/docs\/change-streams<\/a>\nfor more details on how to query the change stream TVFs.\nPartitioned DML transactions:\nPartitioned DML transactions are used to execute DML statements with a\ndifferent execution strategy that provides different, and often better,\nscalability properties for large, table-wide operations than DML in a\nReadWrite transaction. Smaller scoped statements, such as an OLTP workload,\nshould prefer using ReadWrite transactions.\nPartitioned DML partitions the keyspace and runs the DML statement on each\npartition in separate, internal transactions. These transactions commit\nautomatically when complete, and run independently from one another.\nTo reduce lock contention, this execution strategy only acquires read locks\non rows that match the WHERE clause of the statement. Additionally, the\nsmaller per-partition transactions hold locks for less time.\nThat said, Partitioned DML is not a drop-in replacement for standard DML used\nin ReadWrite transactions.<\/li>\n<li>The DML statement must be fully-partitionable. Specifically, the statement\nmust be expressible as the union of many statements which each access only\na single row of the table.<\/li>\n<li>The statement is not applied atomically to all rows of the table. Rather,\nthe statement is applied atomically to partitions of the table, in\nindependent transactions. Secondary index rows are updated atomically\nwith the base table rows.<\/li>\n<li>Partitioned DML does not guarantee exactly-once execution semantics\nagainst a partition. The statement will be applied at least once to each\npartition. It is strongly recommended that the DML statement should be\nidempotent to avoid unexpected results. For instance, it is potentially\ndangerous to run a statement such as\n<code>UPDATE table SET column = column + 1<\/code> as it could be run multiple times\nagainst some rows.<\/li>\n<li>The partitions are committed automatically - there is no support for\nCommit or Rollback. If the call returns an error, or if the client issuing\nthe ExecuteSql call dies, it is possible that some rows had the statement\nexecuted on them successfully. It is also possible that statement was\nnever executed against other rows.<\/li>\n<li>Partitioned DML transactions may only contain the execution of a single\nDML statement via ExecuteSql or ExecuteStreamingSql.<\/li>\n<li>If any error is encountered during the execution of the partitioned DML\noperation (for instance, a UNIQUE INDEX violation, division by zero, or a\nvalue that cannot be stored due to schema constraints), then the\noperation is stopped at that point and an error is returned. It is\npossible that at this point, some partitions have been committed (or even\ncommitted multiple times), and other partitions have not been run at all.\nGiven the above, Partitioned DML is good fit for large, database-wide,\noperations that are idempotent, such as deleting old rows from a very large\ntable.<\/li>\n<\/ul><\/li>\n<\/ol>\n<p>Generated from protobuf message <code>google.spanner.v1.TransactionOptions<\/code><\/p>\n<p>Extends <a href=\"https:\/\/github.com\/protocolbuffers\/protobuf-php\/tree\/v3.21.9\/src\/Google\/Protobuf\/Internal\/Message.php\" target=\"_blank\">Google\\Protobuf\\Internal\\Message<\/a><\/p>","examples":[],"resources":[],"methods":[{"id":"__construct","type":"constructor","name":"__construct","source":"Spanner\/src\/V1\/TransactionOptions.php#L291","description":"<p>Constructor.<\/p>","examples":[],"resources":[],"params":[{"name":"data","description":"<p>Optional. Data for populating the Message object.<\/p>","types":["<a href=\"http:\/\/php.net\/manual\/en\/language.types.array.php\" target=\"_blank\">array<\/a>"],"optional":false,"nullable":null},{"name":"data.read_write\n","description":"<p>Transaction may write. Authorization to begin a read-write transaction requires <code>spanner.databases.beginOrRollbackReadWriteTransaction<\/code> permission on the <code>session<\/code> resource.<\/p>","types":["<a data-custom-type=\"cloud-spanner\/main\/spanner\/v1\/transactionoptions\/readwrite\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\ReadWrite<\/a>"],"optional":null,"nullable":null},{"name":"data.partitioned_dml\n","description":"<p>Partitioned DML transaction. Authorization to begin a Partitioned DML transaction requires <code>spanner.databases.beginPartitionedDmlTransaction<\/code> permission on the <code>session<\/code> resource.<\/p>","types":["<a data-custom-type=\"cloud-spanner\/main\/spanner\/v1\/transactionoptions\/partitioneddml\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\PartitionedDml<\/a>"],"optional":null,"nullable":null},{"name":"data.read_only\n","description":"<p>Transaction will not write. Authorization to begin a read-only transaction requires <code>spanner.databases.beginReadOnlyTransaction<\/code> permission on the <code>session<\/code> resource.<\/p>","types":["<a data-custom-type=\"cloud-spanner\/main\/spanner\/v1\/transactionoptions\/pbreadonly\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\PBReadOnly<\/a>"],"optional":null,"nullable":null}],"exceptions":[],"returns":[]},{"id":"getReadWrite","type":"instance","name":"getReadWrite","source":"Spanner\/src\/V1\/TransactionOptions.php#L305","description":"<p>Transaction may write.<\/p>\n<p>Authorization to begin a read-write transaction requires\n<code>spanner.databases.beginOrRollbackReadWriteTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n<p>Generated from protobuf field <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;<\/code><\/p>","examples":[],"resources":[],"params":[],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"cloud-spanner\/main\/spanner\/v1\/transactionoptions\/readwrite\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\ReadWrite<\/a>","<a href=\"http:\/\/php.net\/manual\/en\/language.types.null.php\" target=\"_blank\">null<\/a>"],"description":""}]},{"id":"setReadWrite","type":"instance","name":"setReadWrite","source":"Spanner\/src\/V1\/TransactionOptions.php#L325","description":"<p>Transaction may write.<\/p>\n<p>Authorization to begin a read-write transaction requires\n<code>spanner.databases.beginOrRollbackReadWriteTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n<p>Generated from protobuf field <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;<\/code><\/p>","examples":[],"resources":[],"params":[{"name":"var","description":"<p>Transaction may write.<\/p>\n<p>Authorization to begin a read-write transaction requires\n<code>spanner.databases.beginOrRollbackReadWriteTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n","types":["<a data-custom-type=\"cloud-spanner\/main\/spanner\/v1\/transactionoptions\/readwrite\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\ReadWrite<\/a>"],"optional":false,"nullable":null}],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"cloud-spanner\/main\/spanner\/v1\/transactionoptions\">Google\\Cloud\\Spanner\\V1\\TransactionOptions<\/a>"],"description":""}]},{"id":"getPartitionedDml","type":"instance","name":"getPartitionedDml","source":"Spanner\/src\/V1\/TransactionOptions.php#L342","description":"<p>Partitioned DML transaction.<\/p>\n<p>Authorization to begin a Partitioned DML transaction requires\n<code>spanner.databases.beginPartitionedDmlTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n<p>Generated from protobuf field <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;<\/code><\/p>","examples":[],"resources":[],"params":[],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"cloud-spanner\/main\/spanner\/v1\/transactionoptions\/partitioneddml\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\PartitionedDml<\/a>","<a href=\"http:\/\/php.net\/manual\/en\/language.types.null.php\" target=\"_blank\">null<\/a>"],"description":""}]},{"id":"setPartitionedDml","type":"instance","name":"setPartitionedDml","source":"Spanner\/src\/V1\/TransactionOptions.php#L362","description":"<p>Partitioned DML transaction.<\/p>\n<p>Authorization to begin a Partitioned DML transaction requires\n<code>spanner.databases.beginPartitionedDmlTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n<p>Generated from protobuf field <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;<\/code><\/p>","examples":[],"resources":[],"params":[{"name":"var","description":"<p>Partitioned DML transaction.<\/p>\n<p>Authorization to begin a Partitioned DML transaction requires\n<code>spanner.databases.beginPartitionedDmlTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n","types":["<a data-custom-type=\"cloud-spanner\/main\/spanner\/v1\/transactionoptions\/partitioneddml\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\PartitionedDml<\/a>"],"optional":false,"nullable":null}],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"cloud-spanner\/main\/spanner\/v1\/transactionoptions\">Google\\Cloud\\Spanner\\V1\\TransactionOptions<\/a>"],"description":""}]},{"id":"getReadOnly","type":"instance","name":"getReadOnly","source":"Spanner\/src\/V1\/TransactionOptions.php#L379","description":"<p>Transaction will not write.<\/p>\n<p>Authorization to begin a read-only transaction requires\n<code>spanner.databases.beginReadOnlyTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n<p>Generated from protobuf field <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;<\/code><\/p>","examples":[],"resources":[],"params":[],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"cloud-spanner\/main\/spanner\/v1\/transactionoptions\/pbreadonly\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\PBReadOnly<\/a>","<a href=\"http:\/\/php.net\/manual\/en\/language.types.null.php\" target=\"_blank\">null<\/a>"],"description":""}]},{"id":"setReadOnly","type":"instance","name":"setReadOnly","source":"Spanner\/src\/V1\/TransactionOptions.php#L399","description":"<p>Transaction will not write.<\/p>\n<p>Authorization to begin a read-only transaction requires\n<code>spanner.databases.beginReadOnlyTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n<p>Generated from protobuf field <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;<\/code><\/p>","examples":[],"resources":[],"params":[{"name":"var","description":"<p>Transaction will not write.<\/p>\n<p>Authorization to begin a read-only transaction requires\n<code>spanner.databases.beginReadOnlyTransaction<\/code> permission\non the <code>session<\/code> resource.<\/p>\n","types":["<a data-custom-type=\"cloud-spanner\/main\/spanner\/v1\/transactionoptions\/pbreadonly\">Google\\Cloud\\Spanner\\V1\\TransactionOptions\\PBReadOnly<\/a>"],"optional":false,"nullable":null}],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"cloud-spanner\/main\/spanner\/v1\/transactionoptions\">Google\\Cloud\\Spanner\\V1\\TransactionOptions<\/a>"],"description":""}]},{"id":"getMode","type":"instance","name":"getMode","source":"Spanner\/src\/V1\/TransactionOptions.php#L410","description":"","examples":[],"resources":[],"params":[],"exceptions":[],"returns":[{"types":["<a href=\"http:\/\/php.net\/manual\/en\/language.types.string.php\" target=\"_blank\">string<\/a>"],"description":""}]}]}